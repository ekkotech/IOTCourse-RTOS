 LAB_3 - LED String Driver Implementation 

 /*** Insert into initSSI function ***/

   for (uint8_t idx = 0; idx < SSI_NUM_CHANNELS; ++idx) {
        // SSI channels are disabled by default after reset
        // Set clock pre-scaler to 2 (divides the system clock by 2 to 24MHz)
        HWREG(ssi[idx].chAdr + SSI_O_CPSR) = SSI_CLOCK_PRESCALE_DIV_2;
        // Configure clock divisor, frame format, data width
        HWREG(ssi[idx].chAdr + SSI_O_CR0) = ((SSI_CLOCK_DIV_6 << SSI_CR0_SCR_S) | SSI_CR0_FRF_TI_SYNC_SERIAL | SSI_CR0_DSS_16_BIT);

        // Set up I/O
        // Set up the output pin for each channel
        temp = HWREG(IOC_BASE + (ssi[idx].ioid * sizeof(uint32_t))) & ~(IOC_IOCFG0_PULL_CTL_M | IOC_IOCFG0_IOCURR_M | IOC_IOCFG0_PORT_ID_M);
        //temp = HWREG(IOC_BASE + (ssi[idx].ioid * sizeof(uint32_t))) & ~IOC_IOCFG0_PULL_CTL_M;
        temp |= (IOC_IOCFG0_PULL_CTL_DWN | IOC_IOCFG0_IOCURR_4MA | ssi[idx].portId);
        HWREG(IOC_BASE + (ssi[idx].ioid * sizeof(uint32_t))) = temp;
        // Enable output
        HWREG(GPIO_BASE + GPIO_O_DOE31_0) |= (1 << ssi[idx].ioid);

        // Enable SSI channel
        HWREG(ssi[idx].chAdr + SSI_O_CR1) |= SSI_CR1_SSE;
   }

/*** End ***/

/*** initDMA guidance comments only ***/
    // Disable all channels before making changes
    
    // Enable the uDMA peripheral
    
    // Set the base address of the uDMA control table at 0x2000_0400 - mask lower bits as a precaution
    

    // The source, destination addresses and transfer modes for both channels do not change so we can set them up here
    
    
    
    // Get current control word and mask off relevant bits
    
    
    

    // Repeat the control block for SSI1
    // The source, destination addresses and transfer modes for both channels do not change so we can set them up here
    
    
    
    // Get current control word and mask off relevant bits
    
    
    

    // Create Hwi
    // Only need a Hwi for SSI channel 1
    
/*** End ***/

/*** Insert into initDMA function ***/
    // Disable all channels before making changes
    HWREG(UDMA0_BASE + UDMA_O_CLEARCHANNELEN) = DMA_ALL_CHANNELS_M;
    // Enable the uDMA peripheral
    HWREG(UDMA0_BASE + UDMA_O_CFG) = UDMA_CFG_MASTERENABLE_M;
    // Set the base address of the uDMA control table at 0x2000_0400 - mask lower bits as a precaution
    HWREG(UDMA0_BASE + UDMA_O_CTRL) = (DMA_CONFIG_BASE_ADDR & UDMA_CTRL_BASEPTR_M);

    // The source, destination addresses and transfer modes for both channels do not change so we can set them up here
    uint32_t control;
    ssi0ControlBlock.pvSrcEndAddr = (volatile uint32_t *)(&bitStream[(NUM_LEDS_PER_STRING * NUM_COLOURS * NIBBLES_PER_BYTE) - 1]);
    ssi0ControlBlock.pvDstEndAddr = (volatile uint32_t *)(SSI0_BASE + SSI_O_DR);
    // Get current control word and mask off relevant bits
    control = (ssi0ControlBlock.ui32Control & ~(DMA_CONTROL_WORD_M));
    control |= (UDMA_DST_INC_NONE | UDMA_SRC_INC_16 | UDMA_SIZE_16 | UDMA_ARB_4 | UDMA_MODE_BASIC);
    ssi0ControlBlock.ui32Control = control;

    ssi1ControlBlock.pvSrcEndAddr = (volatile uint32_t *)(&bitStream[(NUM_LED_STRINGS * NUM_LEDS_PER_STRING * NUM_COLOURS * NIBBLES_PER_BYTE) - 1]) ;
    ssi1ControlBlock.pvDstEndAddr = (volatile uint32_t *)(SSI1_BASE + SSI_O_DR);
    control = (ssi1ControlBlock.ui32Control & ~(DMA_CONTROL_WORD_M));
    control |= (UDMA_DST_INC_NONE | UDMA_SRC_INC_16 | UDMA_SIZE_16 | UDMA_ARB_4 | UDMA_MODE_BASIC);
    ssi1ControlBlock.ui32Control = control;

    // Create Hwi
    // Only need a Hwi for SSI channel 1
    Hwi_create(INT_SSI1_COMB, dmaCompleteHwiFxn, NULL, NULL);
/*** End ***/

/*** Insert into dmaCompleteHwiFxn ***/
    // Disable SSI DMA
    HWREG(SSI0_BASE + SSI_O_DMACR) &= ~SSI_DMACR_TXDMAE_M;
    HWREG(SSI1_BASE + SSI_O_DMACR) &= ~SSI_DMACR_TXDMAE_M;
    // Clear uDMA REQDONE bits
    HWREG(UDMA0_BASE + UDMA_O_REQDONE) = DMA_CHANNEL_SSI1_M;
    // Notify task DMA done
    Semaphore_post(hDmaCompleteSema);
/*** End ***/