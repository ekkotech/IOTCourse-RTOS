 LAB_3 - LED String Driver Implementation 

 /*** Insert into initSSI function ***/
    // Iterate over num SSI channels
   for (uint8_t idx = 0; idx < SSI_NUM_CHANNELS; ++idx) {
        // Disable SSI channel
        HWREG(ssi[idx].chAdr + SSI_O_CR1) &= ~(SSI_CR1_SSE_M);
        // Set clock pre-scaler to 2 (divides the system clock by 2 to 24MHz)
        HWREG(ssi[idx].chAdr + SSI_O_CPSR) = SSI_SRC_CLOCK_DIV_2;
        // Configure clock divisor, frame format, data width
        HWREG(ssi[idx].chAdr + SSI_O_CR0) = ((SSI_CLOCK_DIVISOR << SSI_CR0_SCR_S) | SSI_CR0_FRF_TI_SYNC_SERIAL | SSI_CR0_DSS_16_BIT);

        // Set up I/O
        // Set up the output pin for each channel
        uint32_t temp;
        temp = HWREG(IOC_BASE + (ssi[idx].ioid * sizeof(uint32_t))) & ~(IOC_IOCFG0_PULL_CTL_M | IOC_IOCFG0_IOCURR_M | IOC_IOCFG0_PORT_ID_M);
        temp |= (IOC_IOCFG0_PULL_CTL_DWN | IOC_IOCFG0_IOCURR_4MA | ssi[idx].portId);
        HWREG(IOC_BASE + (ssi[idx].ioid * sizeof(uint32_t))) = temp;
        // Enable output
        HWREG(GPIO_BASE + GPIO_O_DOE31_0) |= (1 << ssi[idx].ioid);

        // Enable SSI channel
        HWREG(ssi[idx].chAdr + SSI_O_CR1) |= SSI_CR1_SSE;
   }

/*** End ***/

/*** Insert into initDMA function ***/

    // Disable all channels before making changes
    HWREG(UDMA0_BASE + UDMA_O_CLEARCHANNELEN) = UDMA_CLEARCHANNELEN_CHNLS_M;
    // Enable the uDMA peripheral
    HWREG(UDMA0_BASE + UDMA_O_CFG) = UDMA_CFG_MASTERENABLE;
    // Set the base address of the uDMA control table. This is fixed at 0x2000_0400 - mask lower bits as a precaution
    HWREG(UDMA0_BASE + UDMA_O_CTRL) = (DMA_CONFIG_BASE_ADDR & UDMA_CTRL_BASEPTR_M);

    // The source, destination addresses and transfer modes for both channels do not change so we can set them up here
    ssi0ControlBlock.pvSrcEndAddr = (uint32_t *)(pBitStream + (NUM_LEDS_PER_STRING * NUM_COLOURS * NIBBLES_PER_BYTE) - 1);
    ssi0ControlBlock.pvDstEndAddr = (uint32_t *)(SSI0_BASE + SSI_O_DR);
    ssi1ControlBlock.pvSrcEndAddr = (uint32_t *)(pBitStream + (NUM_LED_STRINGS * NUM_LEDS_PER_STRING * NUM_COLOURS * NIBBLES_PER_BYTE) - 1);
    ssi1ControlBlock.pvDstEndAddr = (uint32_t *)(SSI1_BASE + SSI_O_DR);

    // The control word for both channels is identical
    uint32_t control = 0;
    control = (UDMA_DST_INC_NONE | UDMA_SRC_INC_16 | UDMA_SIZE_16 | UDMA_ARB_4 | UDMA_MODE_BASIC);
    // This bit-wise AND with zero is to force a read of each control block to keep the compiler happy
    // Without this, the complier thinks that the control blocks are being set but not read hence wasting RAM space
    ssi0ControlBlock.ui32Control = (ssi0ControlBlock.ui32Control & 0) | control;
    ssi1ControlBlock.ui32Control = (ssi1ControlBlock.ui32Control & 0) | control;

    // Create Hwi
    // Only need a Hwi for SSI channel 1
    Hwi_create(INT_SSI1_COMB, dmaCompleteHwiFxn, NULL, NULL);
/*** End ***/

/*** Insert into initResources function ***/
    // Create DMA complete semaphore
    dmaCompleteSemaParams.mode = Semaphore_Mode_BINARY;
    Semaphore_construct(&dmaCompleteSema, 0, &dmaCompleteSemaParams);
    hDmaCompleteSema = Semaphore_handle(&dmaCompleteSema);
/*** End ***/

/*** Insert into dmaCompleteHwiFxn ***/
    // Disable SSI DMA
    HWREGBITW(SSI0_BASE + SSI_O_DMACR, SSI_DMACR_TXDMAE_BITN) = 0;
    HWREGBITW(SSI1_BASE + SSI_O_DMACR, SSI_DMACR_TXDMAE_BITN) = 0;
    // Clear uDMA REQDONE bits
    HWREG(UDMA0_BASE + UDMA_O_REQDONE) = DMA_CHANNEL_SSI_BOTH_M;
    // Notify task DMA done
    Semaphore_post(hDmaCompleteSema);
/*** End ***/

/*** Insert into writeLeds function ***/

    // Ensure that both channels are disabled before making any changes
    if (!(HWREG(UDMA0_BASE + UDMA_O_SETCHANNELEN) & DMA_CHANNEL_SSI_BOTH_M))
    {
        // Configure control words
        uint32_t control;
        uint32_t transferCount = (((NUM_LEDS_PER_STRING * NUM_COLOURS * NIBBLES_PER_BYTE) - 1) << UDMA_XFER_SIZE_S);
        control = ssi0ControlBlock.ui32Control & ~(UDMA_XFER_SIZE_M | UDMA_MODE_M);
        control |= ( transferCount | UDMA_MODE_BASIC );
        ssi0ControlBlock.ui32Control = control;
        ssi1ControlBlock.ui32Control = control;

        // Enable uDMA channels
        HWREG(UDMA0_BASE + UDMA_O_SETCHANNELEN) = DMA_CHANNEL_SSI_BOTH_M;
        // Enable SSI DMA operation
        HWREGBITW(SSI0_BASE + SSI_O_DMACR, SSI_DMACR_TXDMAE_BITN) = 1;
        HWREGBITW(SSI1_BASE + SSI_O_DMACR, SSI_DMACR_TXDMAE_BITN) = 1;

        if (handle != NULL)
        {
            if (Semaphore_pend(handle, timeout * (MSEC_PER_SEC / Clock_tickPeriod)))
            {
                // Ensure that both SSI channels have completed any prior send
                // Add an additional delay to ensure the the 80us reset time for the SK6812 LEDs is met
                waitOnSsiSendComplete();
                Task_sleep(SSI_DELAY_100us / Clock_tickPeriod);
            }
            else
            {
                Log_info0("Semaphore pend timeout");
            }
        }
    }
/*** End ***/

/*** Insert into waitOnSsiSendComplete function ***/
    uint8_t loopCount = 0;

    while (!(HWREG(SSI0_BASE + SSI_O_SR) & SSI_SR_TFE_M) & (HWREG(SSI1_BASE + SSI_O_SR) & SSI_SR_TFE_M))
    {
        Task_sleep(SSI_WAIT_ON_TX_EMPTY_DELAY/Clock_tickPeriod);
        ++loopCount;

        if ((loopCount * SSI_WAIT_ON_TX_EMPTY_DELAY) > SSI_MAX_DELAY)
        {
            break;
        }
    }
/*** End ***/

/*** Insert into processOffOnValueChange ***/
    if ((pCharData->dataLen == sizeof(offon_char_t)))
    {
        led_t thisColour = ledsOff;
        uint16_t rgbLen = sizeof(rgb_char_t);
        rgb_char_t thisRgb;

        if (*((offon_char_t *) pCharData->data))
        {
            LssService_GetParameter( LSS_RGB_ID, &rgbLen, &thisRgb );
            thisColour.green = thisRgb.green;
            thisColour.red = thisRgb.red;
            thisColour.blue = thisRgb.blue;
        }
        bulkUpdateLeds( &thisColour );
        writeLeds( hDmaCompleteSema, LSS_DEFAULT_PEND_TIMEOUT_MS );

    }
/*** End ***/

/*** Insert into processRGBValueChange ***/
    if (pCharData->dataLen == sizeof(rgb_char_t))
    {
        rgb_char_t *pRgb = (rgb_char_t *) pCharData->data;
        led_t grb = { .green = pRgb->green, .red = pRgb->red, .blue = pRgb->blue };
        bulkUpdateLeds( &grb );
        writeLeds( hDmaCompleteSema, LSS_DEFAULT_PEND_TIMEOUT_MS );
    }
/*** End ***/