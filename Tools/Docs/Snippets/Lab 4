/*** Code snippets for Lab 4 - Non-Volatile Memory ***/

/*** In project_zero.c ***/

/*** Global state ***/
//
// SNV state
//
uint8_t gIsSnvDirty = false;
snv_config_t gSnvState = { .offOn = 0,
                           .colour = { .red = 0, .green = 0, .blue = 0},
                           // Add other vars here as needed
                         };

/*** End ***/

/*** Insert into project_zero_init (bottom of) ***/
    // Insert initSnv here
    initSnv( SNV_APP_ID, &gSnvState );
    
/*** End ***/

/*** Insert into initSnv ***/

    uint8_t status = osal_snv_read( appId, sizeof(snv_config_t), pSnvState );

    if (status == SUCCESS) {
        // SNV read OK, set characteristics
        LssService_SetParameter( LSS_OFFON_ID, LSS_OFFON_LEN_MIN, &pSnvState->offOn );
        LssService_SetParameter( LSS_RGB_ID, LSS_RGB_LEN_MIN, &pSnvState->colour );
    }
    else
    {
        // Most likely new firmware uploaded
        // Get default values from characteristics; write to SNV
        uint16_t charLen = LSS_OFFON_LEN_MIN;
        LssService_GetParameter( LSS_OFFON_ID, &charLen, &pSnvState->offOn );
        charLen = LSS_RGB_LEN_MIN;
        LssService_GetParameter( LSS_RGB_ID, &charLen, &pSnvState->colour );

        status = osal_snv_write(appId, sizeof(snv_config_t), pSnvState);
        if (status != SUCCESS)
        {
            Log_info0("Unable to write snvState to FLASH");
        }
    }

/*** End ***/

/*** Insert into local variables section ***/
static Clock_Params periodicClockParams;
static Clock_Struct periodicClock;
/*** End ***/

/*** Insert into project_zero_init (bottom of) ***/
    // Insert clock construct code here

    // Construct the periodic clock
    // Clock fires after an initial STARTUP_EVT_PERIOD milliseconds and every
    // PERIODIC_EVT_PERIOD milliseconds after that
    // Convert milliseconds to clock ticks by multiplying by (MSEC_PER_SEC / Clock_tickPeriod)
    Clock_Params_init(&periodicClockParams);
    periodicClockParams.arg = PRZ_PERIODIC_EVT;
    periodicClockParams.period = PERIODIC_EVT_PERIOD * (MSEC_PER_SEC / Clock_tickPeriod);
    periodicClockParams.startFlag = true;
    Clock_construct(&periodicClock, periodicClockTimeoutSwiFxn,
                    STARTUP_EVT_PERIOD * (MSEC_PER_SEC / Clock_tickPeriod), &periodicClockParams);
    
/*** End ***/

/*** Insert into periodicClockTimeoutSwiFxn ***/
    // Notify the application.
    Event_post(syncEvent, arg);
/*** End ***/

/*** Insert into PRZ_PERIODIC_EVT handler ***/
            if (events & PRZ_PERIODIC_EVT)
            {
                lss_ProcessPeriodicEvent();
                als_ProcessPeriodicEvent();
                saveSnvState( SNV_APP_ID, &gSnvState );
            }
/*** End ***/

/*** Insert into saveSnvState ***/
    //
    // Write out snv structure to SNV if it has changed
    //
    if (gIsSnvDirty == true) {
        uint8_t result = osal_snv_write( appId, sizeof(snv_config_t), (uint8_t *)pState );
        if (result == SUCCESS) {
            gIsSnvDirty = false;
        }
        else {
            Log_info0( "ERROR: writing SNV");
        }
    }
/*** End ***/

/*** Insert into lss_ProcessPeriodicEvent ***/
    if (isFirstRun && (gSnvState.offOn == ON))
    {
        bulkUpdateLeds( &gSnvState.colour );
        writeLeds( hDmaCompleteSema, LSS_DEFAULT_PEND_TIMEOUT_MS );
        isFirstRun = FALSE;
    }
    else {
        saveSnvState( SNV_APP_ID, &gSnvState );
    }

/*** End ***/

/*** Insert into processOffOnValueChange ***/

    if (pCharData->dataLen == sizeof(offon_char_t))
    {
        updateSnvState( pCharData->paramID, pCharData->dataLen, pCharData->data );
        rgb_char_t *pColour = *((offon_char_t *)pCharData->data) == ON ? &gSnvState.colour : &ledsOff;
        bulkUpdateLeds( pColour );
        writeLeds( hDmaCompleteSema, LSS_DEFAULT_PEND_TIMEOUT_MS );
    }
    else {
        Log_info0("Invalid length for offOn data");
    }

/*** End ***/

/*** Insert into processRGBValueChange ***/
    if (pCharData->dataLen == sizeof(rgb_char_t))
    {
        updateSnvState( pCharData->paramID, pCharData->dataLen, pCharData->data );
        if (gSnvState.offOn == ON) {
            bulkUpdateLeds( (rgb_char_t *)pCharData->data );
            writeLeds( hDmaCompleteSema, LSS_DEFAULT_PEND_TIMEOUT_MS );
        }
    }
    else {
        Log_info0("Incorrect data size for RGB value change");
    }


/*** End ***/

/*** Inert into updateSnvState ***/
    switch (charId)
    {
        case LSS_OFFON_ID:
            if (len == LSS_OFFON_LEN)
            {
                gSnvState.offOn = *((offon_char_t *)pData);
            }
            break;

        case LSS_RGB_ID:
            if (len == LSS_RGB_LEN)
            {
                gSnvState.colour = *((rgb_char_t *)pData);
            }
            break;

        default:
            break;
    }

    gIsSnvDirty = true;

/*** End ***/

