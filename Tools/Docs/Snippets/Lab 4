/*** Code snippets for Lab 4 - Non-Volatile Memory ***/

/*** In project_zero.c ***/
/*** Insert into project_zero_init (bottom of) ***/

    initSnv( SNV_APP_ID, &gSnvState );

    // Insert clock construct code here

    // Construct the periodic clock
    // Clock fires after an initial STARTUP_EVT_PERIOD milliseconds and every
    // PERIODIC_EVT_PERIOD milliseconds after that
    // Convert milliseconds to clock ticks by multiplying by (MSEC_PER_SEC / Clock_tickPeriod)
    periodicClockParams.arg = PRZ_PERIODIC_EVT;
    periodicClockParams.period = PERIODIC_EVT_PERIOD * (MSEC_PER_SEC / Clock_tickPeriod);
    periodicClockParams.startFlag = true;
    Clock_construct(&periodicClock, periodicClockTimeoutSwiFxn,
                    STARTUP_EVT_PERIOD * (MSEC_PER_SEC / Clock_tickPeriod), &periodicClockParams);
    
/*** End ***/

/*** Insert into periodicClockTimeoutSwiFxn ***/
    // Notify the application.
    Event_post(syncEvent, arg);
/*** End ***/

/*** Insert into initSnv ***/

    uint8_t status = osal_snv_read( appId, sizeof(snv_config_t), pSnvState );

    if (status == SUCCESS) {
        // SNV read OK, set characteristics
        LssService_SetParameter( LSS_OFFON_ID, LSS_OFFON_LEN_MIN, &pSnvState->offOn );
        LssService_SetParameter( LSS_RGB_ID, LSS_RGB_LEN_MIN, &pSnvState->colour );
    }
    else
    {
        // Most likely new firmware uploaded
        // Get default values from characteristics; write to SNV
        uint16_t charLen = LSS_OFFON_LEN_MIN;
        LssService_GetParameter( LSS_OFFON_ID, &charLen, &pSnvState->offOn );
        charLen = LSS_RGB_LEN_MIN;
        LssService_GetParameter( LSS_RGB_ID, &charLen, &pSnvState->colour );

        status = osal_snv_write(appId, sizeof(snv_config_t), pSnvState);
        if (status != SUCCESS)
        {
            Log_info0("Unable to write snvState to FLASH");
        }
    }

/*** End ***/

/*** Insert into PRZ_PERIODIC_EVT handler ***/
            if (events & PRZ_PERIODIC_EVT)
            {
                lss_ProcessPeriodicEvent( isFirstRun );
                als_ProcessPeriodicEvent( isFirstRun );
                saveSnvState( SNV_APP_ID, &gSnvState );
            }
/*** End ***/

/*** Insert into lss_ProcessPeriodicEvent ***/
    if (isFirstRun && (gSnvState.offOn == ON))
    {
        bulkUpdateLeds( &gSnvState.colour );
        writeLeds( hDmaCompleteSema, LSS_DEFAULT_PEND_TIMEOUT_MS );
        isFirstRun = FALSE;
    }
    else {
        saveSnvState( SNV_APP_ID, &gSnvState );
    }

/*** End ***/

/*** Inert into updateSnvState ***/
    switch (charId)
    {
        case LSS_OFFON_ID:
            if (len == LSS_OFFON_LEN_MIN)
            {
                gSnvState.offOn = *((offon_char_t *)pData);
            }
            break;

        case LSS_RGB_ID:
            if (len == LSS_RGB_LEN_MIN)
            {
                gSnvState.colour = *((rgb_char_t *)pData);
            }
            break;
        
        default:
            break;
    }

    snvIsDirty = true;

/*** End ***/

/*** Insert into saveSnvState ***/
    //
    // Write out snv structure to SNV if it has changed
    //
    if (gIsSnvDirty == true) {
        uint8_t result = osal_snv_write( appId, sizeof(snv_config_t), (uint8_t *)pState );
        if (result == SUCCESS) {
            gIsSnvDirty = false;
        }
        else {
            Log_info0( "ERROR: writing SNV");
        }
    }
/*** End ***/